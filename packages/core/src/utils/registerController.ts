import * as fs from "node:fs"
import * as path from "node:path"
import type { Context, Hono } from "hono"
import type { CreateAppConfig, RouteRecord } from "../app"
import { getBodySchemaBindings, getParamSchemaBindings, getQuerySchemaBindings } from "../decorators"
import { resolve } from "../decorators/inject"
import type { BodySchemaBinding, ParamSchemaBinding, QuerySchemaBinding } from "../types"
import { ApiResponse, formatReturn } from "./response"

// Legacy bindings for simple param/query injection via metadata
type LegacyBindingSource = "param" | "query"
type LegacyBinding = { index: number; source: LegacyBindingSource; name: string }

function normalizeRoutePath(prefix: string, path: string): string {
	const combined = `${prefix}${path}`.replace(/\/{2,}/g, "/")
	if (combined.length > 1 && combined.endsWith("/")) return combined.slice(0, -1)
	return combined
}

type ResponseFlavor = "success" | "error" | "paginated" | "mixed" | "unknown"

type RouteMeta = {
	key: string
	method: string
	path: string
	paramsSchema?: import("zod").ZodTypeAny
	querySchema?: import("zod").ZodTypeAny
	bodySchema?: import("zod").ZodTypeAny
	responseFlavor?: ResponseFlavor
}

function inferResponseFlavorFromSource(fn?: Function): ResponseFlavor {
	if (!fn) return "unknown"
	const src = fn.toString()
	const hasPaginated = /ApiResponse\.paginated\s*\(/.test(src)
	const hasSuccess = /ApiResponse\.success\s*\(/.test(src)
	const hasError = /ApiResponse\.error\s*\(/.test(src)
	if (hasPaginated) return "paginated"
	if (hasSuccess && hasError) return "mixed"
	if (hasSuccess) return "success"
	if (hasError) return "error"
	return "unknown"
}

function sanitizeIdentifier(s: string): string {
	return s.replace(/[^a-zA-Z0-9_]/g, "_")
}

function emitRouteTypes(metaList: RouteMeta[]) {
	const uniqueKeys = Array.from(new Set(metaList.map((m) => m.key)))
	const routeKeyUnion = uniqueKeys.length ? uniqueKeys.map((k) => `'${k}'`).join(" | ") : "never"

	let preamble = `// Generated by Honorer type generator\n// Do not edit manually\n`
	preamble += `\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n`
	preamble += `export type RouteKey = ${routeKeyUnion}\n\n`

	// Response helpers
	preamble += `export type PaginationInfo = { page: number; limit: number; total?: number; pageCount?: number; hasNext?: boolean; hasPrev?: boolean }\n`
	preamble += `export type SuccessResponse<T = unknown> = { status: number; success: true; data: T | T[] | null; pagination?: PaginationInfo; code?: string; message?: string; meta?: Record<string, any> }\n`
	preamble += `export type ErrorResponse<T = unknown> = { status: number; success: false; data: T | T[] | null; pagination?: undefined; code?: string; message: string; meta?: Record<string, any> }\n`
	preamble += `export type PaginatedResponse<T = unknown> = { status: number; success: true; data: T[]; pagination: PaginationInfo; code?: string; message?: string; meta?: Record<string, any> }\n\n`

	// Built-in light Zod â†’ TS converter (no external deps)
	const getTypeName = (schema: any): string => schema?._def?.typeName ?? schema?.constructor?.name ?? "Unknown"
	const unwrap = (schema: any): any => {
		let s = schema
		// unwrap wrappers to get to the inner type
		while (s && ["ZodOptional", "ZodNullable", "ZodDefault", "ZodEffects"].includes(getTypeName(s))) {
			const tn = getTypeName(s)
			if (tn === "ZodOptional") s = s._def?.innerType
			else if (tn === "ZodNullable") s = s._def?.innerType
			else if (tn === "ZodDefault") s = s._def?.innerType
			else if (tn === "ZodEffects") s = s._def?.schema
			else break
		}
		return s
	}
	const toTs = (schema: any): string => {
		const s = unwrap(schema)
		const tn = getTypeName(s)
		switch (tn) {
			case "ZodString":
				return "string"
			case "ZodNumber":
				return "number"
			case "ZodBoolean":
				return "boolean"
			case "ZodBigInt":
				return "bigint"
			case "ZodDate":
				return "Date"
			case "ZodAny":
				return "any"
			case "ZodUnknown":
				return "unknown"
			case "ZodNever":
				return "never"
			case "ZodVoid":
				return "void"
			case "ZodNull":
				return "null"
			case "ZodUndefined":
				return "undefined"
			case "ZodLiteral": {
				const v = s._def?.value
				return typeof v === "string" ? `'${v}'` : String(v)
			}
			case "ZodEnum": {
				const values: any[] = s._def?.values ?? s._def?.options ?? s.options ?? []
				return values.length ? values.map((v) => `'${String(v)}'`).join(" | ") : "string"
			}
			case "ZodNativeEnum": {
				const obj = s._def?.values ?? s._def?.enum ?? {}
				const vals = Object.values(obj).filter((v) => typeof v === "string" || typeof v === "number")
				if (!vals.length) return "unknown"
				return vals.map((v) => (typeof v === "string" ? `'${v}'` : String(v))).join(" | ")
			}
			case "ZodUnion": {
				const options: any[] = s._def?.options ?? []
				return options.map((o) => toTs(o)).join(" | ") || "unknown"
			}
			case "ZodIntersection": {
				const left = s._def?.left
				const right = s._def?.right
				return `(${toTs(left)}) & (${toTs(right)})`
			}
			case "ZodArray": {
				const elem = s.element ?? s._def?.type
				return `${toTs(elem)}[]`
			}
			case "ZodSet": {
				const v = s._def?.valueType
				return `Set<${toTs(v)}>`
			}
			case "ZodMap": {
				const k = s._def?.keyType
				const v = s._def?.valueType
				return `Map<${toTs(k)}, ${toTs(v)}>`
			}
			case "ZodTuple": {
				const items: any[] = s._def?.items ?? []
				return `[${items.map((i) => toTs(i)).join(", ")}]`
			}
			case "ZodRecord": {
				const keyType = s._def?.keyType
				const valType = s._def?.valueType
				const kStr = keyType ? toTs(keyType) : "string"
				return `Record<${kStr}, ${toTs(valType)}>`
			}
			case "ZodObject": {
				const defShape = s._def?.shape
				const shape =
					typeof defShape === "function"
						? defShape()
						: (defShape ?? (typeof s.shape === "function" ? s.shape() : s.shape))
				const entries = Object.entries(shape ?? {})
				if (!entries.length) return "Record<string, never>"
				const props = entries
					.map(([k, v]: [string, any]) => {
						const isOpt = getTypeName(v) === "ZodOptional"
						const inner = unwrap(v)
						return `${k}${isOpt ? "?" : ""}: ${toTs(inner)}`
					})
					.join("; ")
				return `{ ${props} }`
			}
			default:
				return "unknown"
		}
	}

	const aliasDecls: string[] = []
	for (const meta of metaList) {
		const baseId = sanitizeIdentifier(`${meta.method}_${meta.path}`)
		if (meta.paramsSchema) {
			aliasDecls.push(`type RouteParams_${baseId} = ${toTs(meta.paramsSchema)}`)
		}
		if (meta.querySchema) {
			aliasDecls.push(`type RouteQuery_${baseId} = ${toTs(meta.querySchema)}`)
		}
		if (meta.bodySchema) {
			aliasDecls.push(`type RouteBody_${baseId} = ${toTs(meta.bodySchema)}`)
		}
	}

	const routeEntries: string[] = []
	for (const meta of metaList) {
		const baseId = sanitizeIdentifier(`${meta.method}_${meta.path}`)
		const paramsRef = meta.paramsSchema ? `RouteParams_${baseId}` : "unknown"
		const queryRef = meta.querySchema ? `RouteQuery_${baseId}` : "unknown"
		const bodyRef = meta.bodySchema ? `RouteBody_${baseId}` : "unknown"
		let responseType = "SuccessResponse | ErrorResponse | PaginatedResponse"
		switch (meta.responseFlavor) {
			case "paginated":
				responseType = "PaginatedResponse"
				break
			case "success":
				responseType = "SuccessResponse"
				break
			case "error":
				responseType = "ErrorResponse"
				break
			case "mixed":
				responseType = "SuccessResponse | ErrorResponse"
				break
			default:
				responseType = "SuccessResponse | ErrorResponse | PaginatedResponse"
		}
		routeEntries.push(
			`\t'${meta.key}': { params: ${paramsRef}; query: ${queryRef}; body: ${bodyRef}; response: ${responseType} }`,
		)
	}

	const types = `${aliasDecls.join("\n")}\n\nexport interface Routes {\n${routeEntries.join("\n")}\n}`

	const outDir = path.resolve(process.cwd(), ".honorer")
	fs.mkdirSync(outDir, { recursive: true })
	fs.writeFileSync(path.join(outDir, "index.d.ts"), `${preamble}${types}`)
}

export function registerControllers(app: Hono, { options = {}, controllers = [] }: CreateAppConfig): void {
	const { formatResponse = true, generateTypes = true } = options
	// collect meta for type generation
	const routeMeta: RouteMeta[] = []
	for (const Controller of controllers) {
		const prefix: string = Reflect.getMetadata("prefix", Controller) || ""
		const routes: RouteRecord[] = Reflect.getMetadata("routes", Controller) || []
		const instance = resolve(Controller)

		for (const r of routes) {
			const fullPath = normalizeRoutePath(prefix, r.path)
			const propertyKey = r.propertyKey
			const methodFn: ((...args: unknown[]) => unknown) | undefined = propertyKey
				? ((instance as Record<string | symbol, unknown>)[propertyKey] as (...args: unknown[]) => unknown)
				: r.handler
			const boundHandler: (...args: unknown[]) => unknown | Promise<unknown> = methodFn!.bind(instance)
			const bindings: LegacyBinding[] = propertyKey
				? Reflect.getMetadata("route:params", Controller.prototype, propertyKey) || []
				: []

			const paramSchemaBindings: ParamSchemaBinding<any>[] = propertyKey
				? getParamSchemaBindings(Controller.prototype, propertyKey)
				: []

			const querySchemaBindings: QuerySchemaBinding<any>[] = propertyKey
				? getQuerySchemaBindings(Controller.prototype, propertyKey)
				: []

			const bodySchemaBindings: BodySchemaBinding<any>[] = propertyKey
				? getBodySchemaBindings(Controller.prototype, propertyKey)
				: []

			// push meta for generator
			const pickFirstSchema = <T extends { index: number; schema: any }>(arr: T[]) =>
				arr.length ? arr.slice().sort((a, b) => a.index - b.index)[0].schema : undefined
			routeMeta.push({
				key: `${r.method.toUpperCase()} ${fullPath}`,
				method: r.method.toUpperCase(),
				path: fullPath,
				paramsSchema: pickFirstSchema(paramSchemaBindings),
				querySchema: pickFirstSchema(querySchemaBindings),
				bodySchema: pickFirstSchema(bodySchemaBindings),
				responseFlavor: inferResponseFlavorFromSource(methodFn as any),
			})

			if (
				bindings.length > 0 ||
				paramSchemaBindings.length > 0 ||
				querySchemaBindings.length > 0 ||
				bodySchemaBindings.length > 0
			) {
				;(app as any)[r.method](fullPath, async (c: Context) => {
					const maxIndex = Math.max(
						...bindings.map((b) => b.index),
						...paramSchemaBindings.map((s) => s.index),
						...querySchemaBindings.map((s) => s.index),
						...bodySchemaBindings.map((s) => s.index),
						-1,
					)

					let bodyRaw: unknown | undefined
					const args: unknown[] = []
					for (let i = 0; i <= maxIndex; i++) {
						const pSchema = paramSchemaBindings.find((s) => s.index === i)
						if (pSchema) {
							const rawParams = { ...c.req.param() }
							const parsedParams = pSchema.schema.parse(rawParams)
							c.set?.("params", parsedParams)
							args.push(parsedParams)
							continue
						}

						const qSchema = querySchemaBindings.find((s) => s.index === i)
						if (qSchema) {
							const rawQuery = { ...c.req.query() }
							const parsedQuery = qSchema.schema.parse(rawQuery)
							c.set?.("query", parsedQuery)
							args.push(parsedQuery)
							continue
						}

						const bSchema = bodySchemaBindings.find((s) => s.index === i)
						if (bSchema) {
							if (bodyRaw === undefined) bodyRaw = await c.req.json()
							const parsedBody = bSchema.schema.parse(bodyRaw)
							c.set?.("body", parsedBody)
							args.push(parsedBody)
							continue
						}

						const b = bindings.find((x) => x.index === i)
						if (b) {
							if (b.source === "param") args.push(c.req.param(b.name))
							else if (b.source === "query") args.push(c.req.query(b.name))
							else args.push(undefined)
							continue
						}

						args.push(undefined)
					}

					const result = await boundHandler(...args, c)
					if (formatResponse) {
						return await formatReturn(c, result)
					}
					if (result instanceof Response) return result
					if (result instanceof ApiResponse) return result.toResponse(c)
					return c.json(result ?? null)
				})
			} else {
				;(app as any)[r.method](fullPath, async (c: Context) => {
					const result = await boundHandler(c)
					if (formatResponse) {
						return await formatReturn(c, result)
					}
					if (result instanceof Response) return result
					if (result instanceof ApiResponse) return result.toResponse(c)
					return c.json(result ?? null)
				})
			}
		}
	}

	if (generateTypes) {
		emitRouteTypes(routeMeta)
	}
}
